const WhInventory = require('../models/warehouseInventory');
const PurchaseRequest = require('../models/purchaseRequest');
const PurchaseOrder = require('../models/purchaseOrder');
const asyncHandler = require('../middleware/async');
const Item = require('../models/item');
    exports.getWhInventory = (req, res, next) => {
        try {
            WhInventory.find().populate('itemId').then(function(data, err){
                if(err) throw err;
                res.status(200).send({success:true, data: data , message: "Warehouse inventory fetched successfully" });
            })
        } catch (e) {
            res.status(400).send({success:false, message: "Error getting warehouse inventory!", error: e.toString()});
        }
    };

    exports.addWhInventory = (req, res, next) => {
        const { itemId, qty } = req.body;
        
        try{
            WhInventory.create({
                itemId,
                qty
            }).then((response, err) => {
                if(err) throw err;
                res.status(200).send({ success: true, message: "Warehouse inventory added successfully"});
            });
        }
        catch(e){
            res.status(400).send({success:false, message: "Error adding warehouse inventory!", error: e.toString()});
        }
    };

    exports.deleteWhInventory = (req, res, next) => {
        const { _id } = req.params;

        try{
            WhInventory.deleteOne({_id: _id}).then(function(response, err){
                if(err) throw err;
                res.status(200).send({success:true, message: "Warehouse inventory deleted successfully" });
            })
        } catch(e) {
            res.status(400).send({success:false, message: "Error deleting warehouse inventory!", error: e.toString()});
        }
    };

    exports.updateWhInventory = (req, res, next) => {
        const { _id } = req.body;

        try {
            WhInventory.updateOne({_id: _id}, req.body).then(function(){
                res.status(200).send({success:true, message: "Warehouse inventory update successfully" });
            })
        } catch (e) {
            res.status(400).send({success:false, message: "Error updating warehouse inventory!", error: e.toString()});
        }
    };
    exports.requestForInventry = asyncHandler(async (req, res, next)=>{
      try{
          let obj = await ri();
          console.log(obj,'obj')
        let requiredInventry= await obj.requiredInventry;
        
    //    const inventry=await WhInventory.find();
      let vendorId =await obj.vendorId;
    //    let allitems = await Item.find();
     
    //     await  inventry.map(async item=>{
    //     let itemrow=await Item.findById(item.itemId);
       
    //     if(itemrow && (item.qty<itemrow.reorderLevel)){
    //        const req_qnty = itemrow.reorderLevel-item.qty;
    //        let tem1 = JSON.parse(JSON.stringify(item));
    //        let tem2 = JSON.parse(JSON.stringify(itemrow));
    //        tem1.name = itemrow.name
    //        tem1.description = itemrow.description;
    //        tem1.itemCode = itemrow.itemCode;
    //        tem1.reqQty = req_qnty;
    //        tem2.id = item.itemId;
    //         await vendorId.push(tem2);
      
    //       await  requiredInventry.push(tem1)
    //       console.log( requiredInventry,'required---')

    //     }

    //    })
       console.log( requiredInventry,'required filil entity---',vendorId)
// purchase request
if(await requiredInventry){
   
requiredInventry.map(u=>{
    let itemrow= Item.findById(u.itemId);

const purchaseRequest =  PurchaseRequest.create({
    requestNo: uuidv4(),
    generated:'System',
    generatedBy:'System',
    status:'Approved',
    comments:'Purchase request is generated by system',
    reason:'Reactivated Items',
    item:u,
    vendorId :itemrow.vendorId,
    requesterName:null,
    department:null,
    orderType:null
});
console.log(purchaseRequest,'purchase request')
})}
// purchase order
const pr =  await PurchaseRequest.find();

let purchaseRequests = pr.filter(u=>u.generatedBy=='System' && u.status !='Approved');
if(purchaseRequests){
let temp = JSON.parse(JSON.stringify(purchaseRequests))

purchaseRequests.map(u=>{


let prid = temp.filter(i=>{if(i.vendorId==u.vendorId )return i.requestNo} )
if (prid){
let vendorid = prid[0]
const purchaseOrder =  PurchaseOrder.create({
    purchaseOrderNo: uuidv4(),
    purchaseRequestId:prid,
    generated:'System',
    generatedBy:'System',
    date: Date.now(),
    vendorId:vendorid,
    status:'Approved',
});
console.log(purchaseOrder,'0900')
prid.map((a)=>{
    let prtemp_index = -1;
     temp.map((j,index)=>{
         if(j.requestNo == a.requestNo){
            prtemp_index = index;
         }
     })
     if(prtemp_index!=-1){
     delete temp[prtemp_index]

}

})}

prid =[]
})}
res.send({success:true});
 
    }
       catch (e) {
        res.status(400).send({success:false, message: "Error updating warehouse inventory!", error: e.toString()});
    }
      })

       ri = async ()=>{
        let requiredInventry=[];
        const inventry=await WhInventory.find();
        let vendorId = [];
        let allitems = await Item.find();
      
         await  inventry.map(async item=>{
         let itemrow=await Item.findById(item.itemId);
        
         if(itemrow && (item.qty<itemrow.reorderLevel)){
            const req_qnty = itemrow.reorderLevel-item.qty;
            let tem1 = JSON.parse(JSON.stringify(item));
            let tem2 = JSON.parse(JSON.stringify(itemrow));
            tem1.name = itemrow.name
            tem1.description = itemrow.description;
            tem1.itemCode = itemrow.itemCode;
            tem1.reqQty = req_qnty;
            tem2.id = item.itemId;
             await vendorId.push(tem2);
       
           await  requiredInventry.push(tem1)
           console.log( requiredInventry,'required---')
 
         }
 
        })
        console.log(requiredInventry,'required in')
        let obj = {requiredInventry,vendorId}
        return obj;
      }
     